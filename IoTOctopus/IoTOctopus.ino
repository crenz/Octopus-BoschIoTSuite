// Generated by Vorto from com.bosch.si.IoTOctopus:0.0.1

#define USE_SECURE_CONNECTION 1

#include <PubSubClient.h>
#include <ESP8266WiFi.h>
#if (USE_SECURE_CONNECTION == 1)
    #include <WiFiClientSecure.h>
#endif
#include "com_ipso_smartobjects_Accelerometer.h"
#include "com_ipso_smartobjects_Concentration.h"
#include "com_ipso_smartobjects_Analog_Input.h"
#include "com_ipso_smartobjects_Barometer.h"
#include "com_ipso_smartobjects_Gyrometer.h"
#include "com_ipso_smartobjects_Humidity.h"
#include "com_ipso_smartobjects_Magnetometer.h"
#include "com_ipso_smartobjects_Power.h"
#include "com_ipso_smartobjects_Temperature.h"
#include "com_ipso_smartobjects_Light_Control.h"
#include "com_ipso_smartobjects_Light_Control.h"
#include "com_bosch_si_IoTOctopus.h"

/**************************************************************************/
/* Configuration section, adjust to your settings                         */
/**************************************************************************/

/* Your tenant in Eclipse Hono / Bosch IoT Hub */
#define TENANT "BCX18"

/* Define the period of data transmission in ms */
#define MQTT_DATA_PERIOD 10000

/* Define the buffer size for payload strings */
#define MQTT_MAX_SIZE  50

/* MQTT broker endpoint */
const char* mqttServer = "mqtt.bosch-iot-hub.com";
const char* usernameDevice = "@BCX18";
const char* passwordDevice = "<ENTER THE DEVICE PASSWORD HERE>";


#if (USE_SECURE_CONNECTION == 1)
    /* SHA-1 fingerprint of the server certificate of the MQTT broker, UPPERCASE and spacing */
    const char* mqttServerFingerprint = "<xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx>";
#endif

/* WiFi Configuration */
const char* ssid = "<ENTER YOUR WIFI SSID>";
const char* password = "<ENTER YOUR WIFI PASSWORD>";

/* Device Configuration */
String deviceId = "";
	
/* BEGIN SAMPLE CODE */
/* Sample numeric */
long value = 0;

/* Sample text value */
char msg[MQTT_MAX_SIZE];
/* END SAMPLE CODE */

/**************************************************************************/
/* Implementation                                                         */
/**************************************************************************/

/* Port on which the MQTT broker is listening */
#if (USE_SECURE_CONNECTION == 1)
    #define MQTT_SERVER_PORT 8883
#else
    #define MQTT_SERVER_PORT 1883
#endif

/* Topic on which the telemetry data is published */
String telemetryTopic = String("telemetry/") + String(TENANT) + String("/");

/* This variables stores the client ID in the MQTT protocol */
String mqttClientId;

/* Timestamp of previous data transmission */
long lastMqttMsg;

/* Setup WiFi mqttClient and MQTT mqttClient */
#if (USE_SECURE_CONNECTION == 1)
    WiFiClientSecure wifiClient;
#else
    WiFiClient wifiClient;
#endif
PubSubClient mqttClient(wifiClient);

/* The information model object */
com_bosch_si_IoTOctopus infoModel;

/**************************************************************************/
/* Function to connect to the WiFi network                                */
/**************************************************************************/
void setup_wifi() {

    delay(10);
  
    /* We start by connecting to a WiFi network */
    WiFi.begin(ssid, password);

    /* Wait for succesful connection, hang if there is none? */
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
    }

    randomSeed(micros());

    Serial.println("WiFi connected");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
    Serial.print("MAC address: ");
    Serial.println(WiFi.macAddress());
}

/**************************************************************************/
/* Function called when data on a subscribed topic arrives                */
/**************************************************************************/
void mqttDataReceived(char* topic, byte* payload, unsigned int length) {
	
    /* BEGIN SAMPLE CODE */
     
    /* Switch on the builtin LED if a "1" was received as first character for any topic, 
       switch the LED off otherwise */ 
    if ((char)payload[0] == '1') {
  	    /* The LED is switched on LOW signal */
        digitalWrite(BUILTIN_LED, LOW);
    } else {
  	    /* The LED is switched off on HIGH signal */
        digitalWrite(BUILTIN_LED, HIGH);
    }
    
    /* END SAMPE CODE */
}

/**************************************************************************/
/* Reconnect to MQTT broker in case the connection dropped                */
/**************************************************************************/
void reconnect()
{
    /* Loop while not connected */
    while (!mqttClient.connected())
    {		    

        /* If connected to the MQTT broker... */
        if (mqttClient.connect(mqttClientId.c_str(),usernameDevice,passwordDevice))
        {
            /* Re-subscribe */
            /* SAMPLE CODE */
            
            String topic = telemetryTopic + "/led";
            mqttClient.subscribe(topic.c_str());
            
            /* END SAMPLE CODE */
        } else {
    	    /* otherwise wait for 5 seconds before retrying */
            delay(5000);
        }
    }
}

void setup() {
    pinMode(BUILTIN_LED, OUTPUT);     // Initialize the BUILTIN_LED pin as an output
    Serial.begin(115200);
    
    setup_wifi();
  
    /* Create a the MQTT client from the deviceId prefix and the MAC address of the WiFi chip */
    mqttClientId = deviceId;
    //mqttClientId += WiFi.macAddress();
    
    Serial.print("Device ID: ");
    Serial.println(mqttClientId);
    
    /* Add the client ID to the telemetry topic as the final element */
    telemetryTopic += mqttClientId;
  
    /* Configure the MQTT client with the server and callback data */
    mqttClient.setServer(mqttServer, MQTT_SERVER_PORT);
    mqttClient.setCallback(mqttDataReceived);

    #if (USE_SECURE_CONNECTION == 1)
        if (!wifiClient.connect(mqttServer, MQTT_SERVER_PORT)) {
            /* Secure connection failed, start over */
	        ESP.restart();
        }
        else
        {
        	Serial.println("Successfully established secure connection to broker");
		}
		
        if (!wifiClient.verify(mqttServerFingerprint, mqttServer)) {
            /* Verify failed, start over */
	        ESP.restart();
        }
        else
        {
        	Serial.println("Successfully verified server certificate");
        }
    #endif
}

void loop() {

	/* Check if connection to MQTT broker is still good */
    if (!mqttClient.connected()) {
    	/* Reconnect if not */
        reconnect();
    }
    
    /* Event handling of the MQTT client */
    mqttClient.loop();

    /* Publish the telemetry data periodically */
    long now = millis();
    if (now - lastMqttMsg > MQTT_DATA_PERIOD) {
        lastMqttMsg = now;
        
        /* SAMPLE CODE */
        value++;
        snprintf(msg, MQTT_MAX_SIZE - 1, "hello world #%ld", value);
        
        infoModel.accelerometer.setxValue(value);
        infoModel.accelerometer.setyValue(value);
        infoModel.accelerometer.setzValue(value);
        infoModel.accelerometer.setsensorUnits(msg);
        infoModel.accelerometer.setminRangeValue(value);
        infoModel.accelerometer.setmaxRangeValue(value);
        infoModel.airQualityIndex.setsensor_value(value);
        infoModel.airQualityIndex.setsensor_units(msg);
        infoModel.airQualityIndex.setmin_measured_value(value);
        infoModel.airQualityIndex.setmax_measured_value(value);
        infoModel.airQualityIndex.setmin_range_value(value);
        infoModel.airQualityIndex.setmax_range_value(value);
        infoModel.airQualityIndex.setcurrent_calibration(msg);
        infoModel.airQualityIndex.setapplication_type(msg);
        infoModel.analog_input.setanalog_input_current_value(value);
        infoModel.analog_input.setmin_measured_value(value);
        infoModel.analog_input.setmax_measured_value(value);
        infoModel.analog_input.setmin_range_value(value);
        infoModel.analog_input.setmax_range_value(value);
        infoModel.analog_input.setapplication_type(msg);
        infoModel.analog_input.setsensor_type(msg);
        infoModel.barometer.setsensorValue(value);
        infoModel.barometer.setminMeasuredValue(value);
        infoModel.barometer.setmaxMeasuredValue(value);
        infoModel.barometer.setminRangeValue(value);
        infoModel.barometer.setmaxRangeValue(value);
        infoModel.barometer.setsensorUnits(msg);
        infoModel.gyrometer.setxValue(value);
        infoModel.gyrometer.setyValue(value);
        infoModel.gyrometer.setzValue(value);
        infoModel.gyrometer.setsensorUnits(msg);
        infoModel.gyrometer.setminXValue(value);
        infoModel.gyrometer.setmaxXValue(value);
        infoModel.gyrometer.setminYValue(value);
        infoModel.gyrometer.setmaxYValue(value);
        infoModel.gyrometer.setminZValue(value);
        infoModel.gyrometer.setmaxZValue(value);
        infoModel.gyrometer.setminRangeValue(value);
        infoModel.gyrometer.setmaxRangeValue(value);
        infoModel.gyrometer.setapplicationType(msg);
        infoModel.humidity.setsensorValue(value);
        infoModel.humidity.setminMeasuredValue(value);
        infoModel.humidity.setmaxMasuredValue(value);
        infoModel.humidity.setminRangeValue(value);
        infoModel.humidity.setmaxRangeValue(value);
        infoModel.humidity.setsensorUnits(msg);
        infoModel.magnetometer.setxValue(value);
        infoModel.magnetometer.setyValue(value);
        infoModel.magnetometer.setzValue(value);
        infoModel.magnetometer.setcompassDirection(value);
        infoModel.magnetometer.setsensorUnits(msg);
        infoModel.power.setsensor_value(value);
        infoModel.power.setsensor_units(msg);
        infoModel.power.setmin_measured_value(value);
        infoModel.power.setmax_measured_value(value);
        infoModel.power.setmin_range_value(value);
        infoModel.power.setmax_range_value(value);
        infoModel.power.setcurrent_calibration(msg);
        infoModel.power.setapplication_type(msg);
        infoModel.temperature.setsensorValue(value);
        infoModel.temperature.setminMeasuredValue(value);
        infoModel.temperature.setmaxMeasuredValue(value);
        infoModel.temperature.setminRangeValue(value);
        infoModel.temperature.setmaxRangeValue(value);
        infoModel.temperature.setsensorUnits(msg);
        infoModel.rgb1.setcumulativeActivePower(value);
        infoModel.rgb1.setpowerFactor(value);
        infoModel.rgb1.setsensorUnits(msg);
        infoModel.rgb2.setcumulativeActivePower(value);
        infoModel.rgb2.setpowerFactor(value);
        infoModel.rgb2.setsensorUnits(msg);
        /* END OF SAMPLE CODE */
        
        String mqttPayload = infoModel.serialize();
        
        /* Debug output on console */
        Serial.print("Publishing ");
        Serial.print(mqttPayload);
        Serial.print(" to topic ");
        Serial.println(telemetryTopic);
        
        /* Publish all available data to the MQTT broker */
        if (!mqttClient.publish(telemetryTopic.c_str(), mqttPayload.c_str()))
        {
        	Serial.println("Publish failed, if this happens repeatedly increase MQTT_MAX_PACKET_SIZE in PubSubClient.h");
        }
    }
}
